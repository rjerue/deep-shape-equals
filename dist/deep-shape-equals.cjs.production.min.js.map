{"version":3,"file":"deep-shape-equals.cjs.production.min.js","sources":["../src/index.ts"],"sourcesContent":["/**\n * This is where we compare the shape of two objects\n * @param base one object to compare\n * @param test second object to compare\n */\nfunction compare(base: any, test: any, ignoreArrayOrder?: boolean): boolean {\n  //both keys must exist\n  //both keys must be of the same type\n  //both keys must either be, or not be, an array\n  if (\n    [base, test].includes(undefined) ||\n    typeof base !== typeof test ||\n    Array.isArray(base) !== Array.isArray(test)\n  ) {\n    return false; // negative case\n    //If both are arrays, we need to map through\n  } else if (test && Array.isArray(test) && Array.isArray(base)) {\n    // if arrays are of diff size, not the same shape\n    if (base.length !== test.length) {\n      return false;\n    }\n    // We may be doing some splicing later on with this\n    let baseList = [...base];\n    const result = !test\n      .map((elem, i) => {\n        // here we need to compare each elem in both arrays\n        if (ignoreArrayOrder) {\n          const index = baseList.map(e => compare(elem, e)).indexOf(true);\n          if (index === -1) {\n            // not found\n            return false;\n          }\n          baseList.splice(index, 1); //if found, removes from array to prevent repeats\n          return true;\n        }\n        return compare(elem, base[i]);\n      })\n      .includes(false); //if false, then bad\n    if (ignoreArrayOrder && baseList.length !== 0) {\n      return false;\n    }\n    return result;\n    // if it's an object, we go and do a recursive call\n  } else if (test && typeof test === 'object') {\n    return areObjectsSameShape([test, base], ignoreArrayOrder);\n  }\n  return true; //if no reason for things to be wrong, all set\n}\n\n/**\n * checks to see if objects given as args are of the same shape\n * @param objects Args to take in. Array\n * @param ignoreArrayOrder An optional parameter. If false, it will ignore the order of things in arrays, warning that this has unwanted side effects\n */\nexport function areObjectsSameShape(\n  objects: any[],\n  ignoreArrayOrder?: boolean\n): boolean {\n  if (objects.length < 2) {\n    return true;\n  }\n  const base = objects.pop(); //remove one object to serve as the base\n  const baseKeys = Object.keys(base); //we'll use the keys in a few places\n\n  //iterate through all args, compare to base\n  for (const obj of objects) {\n    const keys = Object.keys(obj); // get keys of current\n    const set = new Set([...keys, ...baseKeys]); // create a set of both keys\n    if (set.size !== baseKeys.length) {\n      //if set size of keys is same as key arr, ok\n      return false; //otherwise bad\n    }\n    for (const key of keys) {\n      // here, we'll compare each key, some recursion may happen\n      const ok = compare(obj[key], base[key], ignoreArrayOrder);\n      if (!ok) {\n        //bail if not ok\n        return false;\n      }\n    }\n  }\n  //this means no negative cases were found\n  return true;\n}\n"],"names":["compare","base","test","ignoreArrayOrder","includes","undefined","Array","isArray","length","baseList","result","map","elem","i","index","e","indexOf","splice","areObjectsSameShape","objects","pop","baseKeys","Object","keys","obj","Set","size","key"],"mappings":"aAKA,SAASA,EAAQC,EAAWC,EAAWC,MAKnC,CAACF,EAAMC,GAAME,cAASC,WACfJ,UAAgBC,GACvBI,MAAMC,QAAQN,KAAUK,MAAMC,QAAQL,UAE/B,EAEF,GAAIA,GAAQI,MAAMC,QAAQL,IAASI,MAAMC,QAAQN,GAAO,IAEzDA,EAAKO,SAAWN,EAAKM,cAChB,MAGLC,YAAeR,GACbS,GAAUR,EACbS,IAAI,SAACC,EAAMC,MAENV,EAAkB,KACdW,EAAQL,EAASE,IAAI,SAAAI,UAAKf,EAAQY,EAAMG,KAAIC,SAAQ,UAC3C,IAAXF,IAIJL,EAASQ,OAAOH,EAAO,IAChB,UAEFd,EAAQY,EAAMX,EAAKY,MAE3BT,UAAS,WACRD,GAAwC,IAApBM,EAASD,SAG1BE,EAEF,OAAIR,GAAwB,iBAATA,GACjBgB,EAAoB,CAAChB,EAAMD,GAAOE,YAU7Be,EACdC,EACAhB,MAEIgB,EAAQX,OAAS,SACZ,MAEHP,EAAOkB,EAAQC,MACfC,EAAWC,OAAOC,KAAKtB,KAGXkB,0DAAS,yFAAhBK,IACHD,EAAOD,OAAOC,KAAKC,MACb,IAAIC,cAAQF,EAASF,IACzBK,OAASL,EAASb,cAEjB,gBAESe,iBAAM,KAAbI,WAEE3B,EAAQwB,EAAIG,GAAM1B,EAAK0B,GAAMxB,UAG/B,UAKN"}